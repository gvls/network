##  HTTP2.0
基于`HTTPS` 
在TCP层上采用`TLS` 
在`TLS` 层上采用 `HPack` 和`Stream` 
对`HTTP1.1` 改进

it use binary format rather than text
it use `多路复用` : `实现` response more `request` 
it use `包头压缩` 
it can make `response` `主动地` push to cache of `client` 

###   头部压缩
压缩头部
若同时发送多个请求，若头都是一样/相似的，协议会消除重复的部分
* HPACK算法
客户端和服务端同时维护一张头信息表，所有字段存入表中，并生成一个索引号
以后只需要发索引号就行


###   二进制
使用使用二进制代替纯文本
头信息和数据都是二进制，并统称为帧（头信息帧、数据帧）
服务器收到信息后无序把报文转成二进制，增加数据传输效率
####    例子
200
* 文本
```shell
字符'2''0''0' => 110010 110000 110000
```
* 二进制
```shell
数字200 =>  11001000
```


###   数据流
数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应，对数据包做标记，指出它属于哪个回应。
每个数据流都标记着一个独一无二的编号，不同数据流的帧是可以乱序发送的（并发发送）
客户端通过帧的头部的数据流编号把所有帧组装为HTTP信息
客户端建立的数据流的编号 必须是奇数号，服务器建立的数据流的编号 必须是偶数号。
客户端可以指定数据流的优先级

* 一个数据流
每个请求/相应的所有数据包



###   多路复用
可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。
移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现 队头阻塞 问题，降低了延迟，大幅度提高了连接的利用率。
* 例子
在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。


###   服务器推送
改善了传统的 请求-应答 通信模式，服务不只是被动地响应，也可以主动向客户端发送消息。
* 例子
客户端请求了HTML，不需要再请求CSS，服务器推送CSS


###   缺点
HTTP2.0还存在队头阻塞，只是发生在TCP
在TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，当 前 1 个字节数据 没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP2.0 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。
一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。
